# Objective

Create malware that has requirements that must be met before it is executed. Open the code in xgb32 


## Malware

The malware is simple, check if the user executed the exe with admin privlidges, if so, create a flag in the users docmuents folder. The final iteration will encode
the payload. 

```
#include <stdio.h>
#include <windows.h>
#include <shlobj.h>

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the flag content
        const char* flag = "FLAG{your_flag_here}";

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the flag content to the file
                fprintf(file, "%s\n", flag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
     
```

We use the net session as a proxy to determine privs. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/6fa5ff6c-8a44-497d-aa55-002628455a77)

![image](https://github.com/dbissell6/DFIR/assets/50979196/092026f7-6caf-4733-95e4-7df49223d05a)

Now lets compile and run on the target machine. The expected outcome is the flag should only be created when run with elevated privs.

![image](https://github.com/dbissell6/DFIR/assets/50979196/d9f4a66b-cba5-43f3-9cd8-d665b81ab67a)


![image](https://github.com/dbissell6/DFIR/assets/50979196/15dd6410-4c86-4542-94de-308a3fed5f08)


![image](https://github.com/dbissell6/DFIR/assets/50979196/c1b7539f-33a1-4bba-9d17-c0ab76e00f28)

This shows the check is working as intended. Lets base64 encode the payload to spice up the challenge a little, if not strings would easily reveal the flag.

```
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlobj.h>
#include <wininet.h>

char* base64Decode(const char* input) {
    DWORD len = 0;
    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, NULL, &len, NULL, NULL)) {
        return NULL;
    }

    char* buffer = (char*)malloc(len);
    if (buffer == NULL) {
        return NULL;
    }

    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, (BYTE*)buffer, &len, NULL, NULL)) {
        free(buffer);
        return NULL;
    }

    return buffer;
}

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the Base64 encoded flag content
        const char* base64EncodedFlag = "VmlWaXtHaG9zdF9Jbl9UaGVfQm94fQo=";

        // Decode the Base64 encoded flag
        char* decodedFlag = base64Decode(base64EncodedFlag);

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the decoded flag content to the file
                fprintf(file, "%s\n", decodedFlag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }

        free(decodedFlag); // Free the dynamically allocated memory
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
```

Compile

![image](https://github.com/dbissell6/DFIR/assets/50979196/801b051a-c395-40ca-b75e-d9ca5430119e)

Show flag is not created for normal privs
![image](https://github.com/dbissell6/DFIR/assets/50979196/7faff1ef-0f77-4f45-a96c-ae8e56be03b0)


![image](https://github.com/dbissell6/DFIR/assets/50979196/b9f57470-d259-4599-bbbb-cfba923a8168)


# Analysis

Now that we have a piece of maleware working as intended and we know exactly how it should work, we can analyze it using debugging. In reality there may be many more checks
a piece of malware uses before deploying itself. It may also check if the host is connected to the internet, if the host is a vm, GPU capabilities, many things.

The goal of this exercise will be to open the malware in debugger as the normal user, but manually alter the check the code performs so the flag will be deplaoyed for the
normal user.


