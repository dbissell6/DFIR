# Objective

Create malware that has requirements that must be met before it is executed. Open the code in a debugger and alter the execution to bypass the checks.  


## Malware

The malware is simple, check if the user executed the exe with admin privlidges, if so, create a flag in the users docmuents folder. The final iteration will encode
the payload. 

```
#include <stdio.h>
#include <windows.h>
#include <shlobj.h>

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the flag content
        const char* flag = "FLAG{your_flag_here}";

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the flag content to the file
                fprintf(file, "%s\n", flag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
     
```

We use the net session as a proxy to determine privs. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/6fa5ff6c-8a44-497d-aa55-002628455a77)

![image](https://github.com/dbissell6/DFIR/assets/50979196/092026f7-6caf-4733-95e4-7df49223d05a)

Now lets compile and run on the target machine. The expected outcome is the flag should only be created when run with elevated privs.

![image](https://github.com/dbissell6/DFIR/assets/50979196/d9f4a66b-cba5-43f3-9cd8-d665b81ab67a)


![image](https://github.com/dbissell6/DFIR/assets/50979196/15dd6410-4c86-4542-94de-308a3fed5f08)


![image](https://github.com/dbissell6/DFIR/assets/50979196/c1b7539f-33a1-4bba-9d17-c0ab76e00f28)

This shows the check is working as intended. Lets base64 encode the payload to spice up the challenge a little, if not strings would easily reveal the flag.

```
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlobj.h>
#include <wininet.h>

char* base64Decode(const char* input) {
    DWORD len = 0;
    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, NULL, &len, NULL, NULL)) {
        return NULL;
    }

    char* buffer = (char*)malloc(len);
    if (buffer == NULL) {
        return NULL;
    }

    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, (BYTE*)buffer, &len, NULL, NULL)) {
        free(buffer);
        return NULL;
    }

    return buffer;
}

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the Base64 encoded flag content
        const char* base64EncodedFlag = "VmlWaXtHaG9zdF9Jbl9UaGVfQm94fQo=";

        // Decode the Base64 encoded flag
        char* decodedFlag = base64Decode(base64EncodedFlag);

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the decoded flag content to the file
                fprintf(file, "%s\n", decodedFlag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }

        free(decodedFlag); // Free the dynamically allocated memory
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
```

Compile

![image](https://github.com/dbissell6/DFIR/assets/50979196/801b051a-c395-40ca-b75e-d9ca5430119e)

Show flag is not still not created for normal privs

![image](https://github.com/dbissell6/DFIR/assets/50979196/7faff1ef-0f77-4f45-a96c-ae8e56be03b0)


![image](https://github.com/dbissell6/DFIR/assets/50979196/b9f57470-d259-4599-bbbb-cfba923a8168)


# Analysis

Now that we have a piece of 'malware' working as intended and we know exactly how it should work, we can use dynamic analysis and debugging. In reality there may be many more checks a piece of malware uses before deploying itself. It may also check if the host is connected to the internet, if the host is a vm,
GPU capabilities, many things. The ideal situation for this is if we cannot get the payload through static analysis.



The goal of this exercise will be to open the malware in debugger as the normal user, but manually alter the code which performs the check on the isAdmin function so the flag will be deployed for the normal user.

First step is finding the cmp to enter the admin branch of the logic. For our purposes we can search string for admin and look at the first jmp that comes before that string. Right Click -> Search for -> Current Module -> String References

![image](https://github.com/dbissell6/DFIR/assets/50979196/2dcdb115-202f-4d8b-9dc1-f37d50adfd36)

Click the line with cmp add a break point

![image](https://github.com/dbissell6/DFIR/assets/50979196/cff1d57a-4a54-4625-9438-1aa8a8b61ce5)


This screenshot is the heart of the problem. The isadmin function will return 0, when encoded.exe it is ran when a priviliged user. We can see at the bottom of the screenshot that the current output of the function = 2. 2 != 0 so we arnt getting the the branch we want. We can change this.

![image](https://github.com/dbissell6/DFIR/assets/50979196/cfa61017-56af-4aa7-8632-f82e22320791)

click on that line, press space, change value to 2. Now 2 == 2 so we will enter into the is admin branch.

![image](https://github.com/dbissell6/DFIR/assets/50979196/be83a60e-91b9-45d3-b181-8fb2eb92a56e)

![image](https://github.com/dbissell6/DFIR/assets/50979196/42c795eb-bc48-447d-8861-99393bd7436b)

Last screenshot shows documents folder was empty before debugging was ran and the flag in the folder after it was ran with normal privs.

![image](https://github.com/dbissell6/DFIR/assets/50979196/67b56263-3169-4c11-a029-0574a20d43dd)



## 

Becasue we made the malware we knew 2 keys that typically make the process much more difficult. 
1) The logic behind the check
2) the location of the created file


Typically malware isnt going to tell you what or where it just did what it did. We can find the location of the create file by using procmon

Filter -> Process Name is 'encoded.exe'

![image](https://github.com/dbissell6/DFIR/assets/50979196/2aa259d2-af8a-473c-966d-3a261639e337)


# The same path in with a linux binary
shell script
```
#!/bin/bash

# Check if the user has administrative privileges
if [[ $(id -u) -eq 0 ]]; then
    echo "You have administrative privileges."

    # Define the flag content
    flag="FLAG{your_flag_here}"

    # Get the user's home directory
    homeDir=$(eval echo "~$USER")

    # Construct the path to the flag file in the home dir
    filePath="$homeDir/flag.txt"

    # Write the flag content to the file
    echo "$flag" > "$filePath"
    echo "Flag file created in the home directory: $filePath"
else
    echo "You do not have administrative privileges."
fi
```

in c to compile to use gdb
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>

int main() {
    // Get the effective user ID (EUID)
    uid_t euid = geteuid();

    // Check if the user has administrative privileges
    if (euid == 0) {
        printf("You have administrative privileges.\n");

        // Define the flag content
        const char* flag = "FLAG{your_flag_here}";

        // Get the user's home directory
        struct passwd *pw = getpwuid(getuid());
        const char *homeDir = pw->pw_dir;
        printf("User's home directory is: %s\n", homeDir);

        // Construct the path to the flag file in the home dir
        char filePath[256];
        snprintf(filePath, sizeof(filePath), "%s/flag.txt", homeDir);
        printf("Flag file path is: %s\n", filePath);

        // Open the file for writing
        FILE* file = fopen(filePath, "w");
        if (file != NULL) {
            // Write the flag content to the file
            fprintf(file, "%s\n", flag);
            fclose(file);
            printf("Flag file created in the home directory: %s\n", filePath);
        } else {
            printf("Failed to create the flag file.\n");
        }
    } else {
        printf("You do not have administrative privileges.\n");
    }

    return 0;
}
  
        
```

Show functionality is working as intended

![image](https://github.com/dbissell6/DFIR/assets/50979196/6bb1aaad-96cc-4362-b958-43067d033374)


## Open up gdb to begin debugging

adminfile2 was compiled with debugging to help illustrate exactly where we are in the c code. 
```
gcc -g -o admin_file2 admin_file2.c
```


On the top of the screenshot we can see the cmp, whatever is in [rbp-0x4] will be compared to 0x0. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/bb0b2982-b408-4d38-af9f-1ea78af69456)

2/3 down the screenshot we see the current value being held, 1000. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/8866ed5a-33ff-4d4f-a3e4-d72f7871b3f4)

```
    x is the examine command.
    /dw specifies the format for displaying the value (signed decimal word, which is a 32-bit integer).
    $rbp-0x4 is the address you want to examine.
```


We can overwrite this with the next command and continue. 
```
This command casts the address $rbp-0x4 to a pointer to an integer (int*) and then sets the value at that address to 0.
```

Finally we can see the bypass worked and the flag was printed to the curent users desktop

![image](https://github.com/dbissell6/DFIR/assets/50979196/3e47c3a5-c528-40b3-aae4-88a427d6cf7f)


## Beyond

Just like last time we have an issue malware wont tell you where it created a file. On linux we can use strace.
Here we use the trace=file, process is an option too.

Running strace and the program with normal privs yields the expected results.
![image](https://github.com/dbissell6/DFIR/assets/50979196/e25ac30a-a51d-4991-b641-38b4538a3b1b)

Running as root we see an openat containing the flag.
![image](https://github.com/dbissell6/DFIR/assets/50979196/10fe59e5-71e3-47c9-a50d-598d105146e7)

# Tracerpid and proc/self/status


![image](https://github.com/dbissell6/DFIR/assets/50979196/d4d658e3-74af-4dc2-b6e2-5df1b3892076)


![image](https://github.com/dbissell6/DFIR/assets/50979196/7e0691c0-3d43-484b-ae6b-aa8b6f07a5dd)



![image](https://github.com/dbissell6/DFIR/assets/50979196/163c9702-233d-444f-9bcc-e7286e003d2e)



![image](https://github.com/dbissell6/DFIR/assets/50979196/4897b942-fb1b-4811-a55e-5994e76a87f4)

![image](https://github.com/dbissell6/DFIR/assets/50979196/a2c0bd0f-4c4e-4d70-9e70-eea06dd9e8fc)

![image](https://github.com/dbissell6/DFIR/assets/50979196/19745855-ba19-4036-a041-939eafd8a9d2)


![image](https://github.com/dbissell6/DFIR/assets/50979196/29aa3856-d30c-4c9f-9b43-54bdc5a8b90e)

![image](https://github.com/dbissell6/DFIR/assets/50979196/028d9f21-d769-4f07-89f5-1b9ddf57ba79)




![image](https://github.com/dbissell6/DFIR/assets/50979196/7beb28d9-8ad4-4111-ab99-a1e220ea4797)

Right click set breakpoint

![image](https://github.com/dbissell6/DFIR/assets/50979196/fb562ae7-9268-4025-bbdc-007b7e9aa644)


Ghidra debugger SW_EXECUTE

![image](https://github.com/dbissell6/DFIR/assets/50979196/ed813d49-982f-4631-9d76-620922d2e572)


![image](https://github.com/dbissell6/DFIR/assets/50979196/59defcaf-98e0-4aff-868a-0da9ebc42092)


Change the binary

We can see here it will only take the jump to the desired function if does not =0. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/a6747e23-8b4a-461b-bc0b-dc0d16e25429)


Right click and select Patch Instruction. Here was can champ JNE to JMP, this means the previous test doesnt matter, the program will now always take that jump.

![image](https://github.com/dbissell6/DFIR/assets/50979196/d2bc86e3-3775-4622-8ab3-08566271e935)

To save new binary

File -> Export Program -> Format(Original File)

Now we can run strace as sudo, notice de

![image](https://github.com/dbissell6/DFIR/assets/50979196/641115c2-d0a1-4878-b036-40a03cf2bde5)


![image](https://github.com/dbissell6/DFIR/assets/50979196/62fd961d-d556-4067-90ec-593b8a0961b7)




