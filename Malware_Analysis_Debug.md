# Objective

Create malware that has requirements that must be met before it is executed. Open the code in x32dbg. 


## Malware

The malware is simple, check if the user executed the exe with admin privlidges, if so, create a flag in the users docmuents folder. The final iteration will encode
the payload. 

```
#include <stdio.h>
#include <windows.h>
#include <shlobj.h>

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the flag content
        const char* flag = "FLAG{your_flag_here}";

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the flag content to the file
                fprintf(file, "%s\n", flag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
     
```

We use the net session as a proxy to determine privs. 

![image](https://github.com/dbissell6/DFIR/assets/50979196/6fa5ff6c-8a44-497d-aa55-002628455a77)

![image](https://github.com/dbissell6/DFIR/assets/50979196/092026f7-6caf-4733-95e4-7df49223d05a)

Now lets compile and run on the target machine. The expected outcome is the flag should only be created when run with elevated privs.

![image](https://github.com/dbissell6/DFIR/assets/50979196/d9f4a66b-cba5-43f3-9cd8-d665b81ab67a)


![image](https://github.com/dbissell6/DFIR/assets/50979196/15dd6410-4c86-4542-94de-308a3fed5f08)


![image](https://github.com/dbissell6/DFIR/assets/50979196/c1b7539f-33a1-4bba-9d17-c0ab76e00f28)

This shows the check is working as intended. Lets base64 encode the payload to spice up the challenge a little, if not strings would easily reveal the flag.

```
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlobj.h>
#include <wininet.h>

char* base64Decode(const char* input) {
    DWORD len = 0;
    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, NULL, &len, NULL, NULL)) {
        return NULL;
    }

    char* buffer = (char*)malloc(len);
    if (buffer == NULL) {
        return NULL;
    }

    if (!CryptStringToBinaryA(input, 0, CRYPT_STRING_BASE64, (BYTE*)buffer, &len, NULL, NULL)) {
        free(buffer);
        return NULL;
    }

    return buffer;
}

int main() {
    int isAdmin = system("net session > nul 2>&1");

    if (isAdmin == 0) {
        printf("You have admin rights.\n");

        // Define the Base64 encoded flag content
        const char* base64EncodedFlag = "VmlWaXtHaG9zdF9Jbl9UaGVfQm94fQo=";

        // Decode the Base64 encoded flag
        char* decodedFlag = base64Decode(base64EncodedFlag);

        // Get the path to the user's Documents folder
        WCHAR documentsPath[MAX_PATH];
        if (S_OK == SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, documentsPath)) {
            // Construct the path to the file in the Documents folder
            WCHAR filePath[MAX_PATH];
            wcscpy(filePath, documentsPath);
            wcscat(filePath, L"\\flag.txt");

            // Open the file for writing
            FILE* file = _wfopen(filePath, L"w");
            if (file != NULL) {
                // Write the decoded flag content to the file
                fprintf(file, "%s\n", decodedFlag);
                fclose(file);
                wprintf(L"Flag file created in Documents folder: %ls\n", filePath);
            } else {
                printf("Failed to create the flag file.\n");
            }
        } else {
            printf("Failed to get the Documents folder path.\n");
        }

        free(decodedFlag); // Free the dynamically allocated memory
    } else {
        printf("You do not have admin rights.\n");
    }

    return 0;
}
```

Compile

![image](https://github.com/dbissell6/DFIR/assets/50979196/801b051a-c395-40ca-b75e-d9ca5430119e)

Show flag is not still not created for normal privs

![image](https://github.com/dbissell6/DFIR/assets/50979196/7faff1ef-0f77-4f45-a96c-ae8e56be03b0)


![image](https://github.com/dbissell6/DFIR/assets/50979196/b9f57470-d259-4599-bbbb-cfba923a8168)


# Analysis

Now that we have a piece of 'malware' working as intended and we know exactly how it should work, we can use dynamic analysis and debugging. In reality there may be many more checks a piece of malware uses before deploying itself. It may also check if the host is connected to the internet, if the host is a vm,
GPU capabilities, many things. The ideal situation for this is if we cannot get the payload through static analysis.



The goal of this exercise will be to open the malware in debugger as the normal user, but manually alter the code which performs the check on the isAdmin function so the flag will be deployed for the normal user.

First step is finding the cmp to enter the admin branch of the logic. For our purposes we can search string for admin and look at the first jmp that comes before that string. Right Click -> Search for -> Current Module -> String References

![image](https://github.com/dbissell6/DFIR/assets/50979196/2dcdb115-202f-4d8b-9dc1-f37d50adfd36)

Click the line with cmp add a break point

![image](https://github.com/dbissell6/DFIR/assets/50979196/cff1d57a-4a54-4625-9438-1aa8a8b61ce5)


This screenshot is the heart of the problem. The isadmin function will return 0, when encoded.exe it is ran when a priviliged user. We can see at the bottom of the screenshot that the current output of the function = 2. 2 != 0 so we arnt getting the the branch we want. We can change this.

![image](https://github.com/dbissell6/DFIR/assets/50979196/cfa61017-56af-4aa7-8632-f82e22320791)

click on that line, press space, change value to 2. Now 2 == 2 so we will enter into the is admin branch.

![image](https://github.com/dbissell6/DFIR/assets/50979196/be83a60e-91b9-45d3-b181-8fb2eb92a56e)

![image](https://github.com/dbissell6/DFIR/assets/50979196/42c795eb-bc48-447d-8861-99393bd7436b)

Last screenshot shows documents folder was empty before debugging was ran and the flag in the folder after it was ran with normal privs.

![image](https://github.com/dbissell6/DFIR/assets/50979196/67b56263-3169-4c11-a029-0574a20d43dd)



## 

Becasue we made the malware we knew 2 keys that typically make the process much more difficult. 
1) The logic behind the check
2) the location of the created file


Typically malware isnt going to tell you what or where it just did what it did. We can find the location of the create file by using procmon

Filter -> Process Name is 'encoded.exe'

![image](https://github.com/dbissell6/DFIR/assets/50979196/2aa259d2-af8a-473c-966d-3a261639e337)


